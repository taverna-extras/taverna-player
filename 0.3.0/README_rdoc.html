<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>README - Taverna Player</title>

<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script type="text/javascript" charset="utf-8" src="./js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/darkfish.js"></script>


<body class="file">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="./index.html">Home</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="./CHANGES_rdoc.html">CHANGES</a>
  
    <li class="file"><a href="./LICENCE_rdoc.html">LICENCE</a>
  
    <li class="file"><a href="./README_rdoc.html">README</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="./TavernaPlayer.html">TavernaPlayer</a>
  
    <li><a href="./TavernaPlayer/ApplicationHelper.html">TavernaPlayer::ApplicationHelper</a>
  
    <li><a href="./TavernaPlayer/PortRenderer.html">TavernaPlayer::PortRenderer</a>
  
    <li><a href="./TavernaPlayer/Run.html">TavernaPlayer::Run</a>
  
    <li><a href="./TavernaPlayer/RunPort.html">TavernaPlayer::RunPort</a>
  
    <li><a href="./TavernaPlayer/RunPort/Input.html">TavernaPlayer::RunPort::Input</a>
  
    <li><a href="./TavernaPlayer/RunPort/Output.html">TavernaPlayer::RunPort::Output</a>
  
    <li><a href="./TavernaPlayer/ServiceCredential.html">TavernaPlayer::ServiceCredential</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation" class="description">
  
<h1 id="label-Taverna+Player">Taverna Player</h1>
<dl class="rdoc-list note-list"><dt>Authors
<dd>
<p>Robert Haines</p>
</dd><dt>Contact
<dd>
<p><a href="mailto:support@mygrid.org.uk">support@mygrid.org.uk</a></p>
</dd><dt>URL
<dd>
<p><a href="http://www.taverna.org.uk">www.taverna.org.uk</a></p>
</dd><dt>Licence
<dd>
<p>BSD (See <a href="LICENCE_rdoc.html">LICENCE</a> or <a
href="http://www.opensource.org/licenses/bsd-license.php">www.opensource.org/licenses/bsd-license.php</a>)</p>
</dd><dt>Copyright
<dd>
<p>© 2013 The University of Manchester, UK</p>
</dd></dl>

<p><a href="http://badge.fury.io/rb/taverna-player"><img
src="https://badge.fury.io/rb/taverna-player.png" alt="Gem Version" /></a>
<a href="https://codeclimate.com/github/myGrid/taverna-player"><img
src="https://codeclimate.com/github/myGrid/taverna-player.png" /></a></p>

<h2 id="label-Synopsis">Synopsis</h2>

<p>Taverna Player is a Ruby on Rails plugin to run Taverna workflows on a
Taverna Server.</p>

<p>Taverna Player handles all aspects of running a workflow including:</p>
<ul><li>
<p>Gathering inputs and upload to Taverna Server</p>
</li><li>
<p>Monitoring the run</p>
</li><li>
<p>Presenting workflow interactions to the user</p>
</li><li>
<p>Gathering and download of workflow outputs</p>
</li></ul>

<p>It, purposefully, does not:</p>
<ul><li>
<p>Manage workflows</p>
</li><li>
<p>Manage users</p>
</li></ul>

<h2 id="label-Getting+started">Getting started</h2>

<p>These instructions assume that you are familiar with Rails and its
concepts. Also, knowledge of <a
href="http://guides.rubyonrails.org/engines.html">Rails Engines</a> and how
they integrate with other Rails applications will be useful.</p>

<p>Taverna Player works with Rails 3.2. Add it to your Gemfile with:</p>

<pre>gem &quot;taverna-player&quot;</pre>

<p>And run the <code>bundle install</code> command to install it.</p>

<p>Next you need to run the install generator:</p>

<pre>rails generate taverna_player:install</pre>

<p>This installs two initializer files (into your application’s
<code>config/initializers</code> directory) which describe all of Taverna
Player’s configuration options; there are some things that MUST be
configured before it will work - see below for more information. The
install generator also prints out a list of other steps for setting up
Taverna Player; these are repeated and detailed below.</p>

<h2 id="label-Running+Taverna+Player">Running Taverna Player</h2>

<p>Once you have Taverna Player installed and configured in your Rails
application it will largely take care of itself. The nature of Rails
Engines is that they become part of the containing application relatively
seamlessly.</p>

<p>The only extra step required for full operation of Taverna Player is to
start the delayed_job script so that workflows are actually run. Even if
you already use delayed_job in your application it is worth checking this
section because Taverna Player uses its own named queue to run jobs.</p>

<h3 id="label-In+development">In development</h3>

<p>If you simply want to have a single worker running while testing then you
can use the rake task supplied by delayed_job:</p>

<pre>rake jobs:work</pre>

<h3 id="label-In+production">In production</h3>

<p>In production you will want to run lots of workers for maximum throughput.
A good starting number of concurrent workers will probably be the number of
workflows that your Taverna Server can run at the same time. Any lower than
this and you are not running Taverna Server at its configured capacity; any
higher and you just end up with workers waiting for Taverna Server to have
space for them anyway. You might pick up some efficiencies starting new
workflow runs while the results of those just finished are being collected
but it is probably not worth having more than one or two extra workers for
this.</p>

<p>So if your Taverna Server can run 20 concurrent workflows at once then you
would start your workers like this:</p>

<pre>RAILS_ENV=production bundle exec ./script/delayed_job -n 20 --queue=player start</pre>

<p>See the documentation for <a
href="https://rubygems.org/gems/delayed_job">delayed_job</a> for more
options and information.</p>

<h2 id="label-Hooking+Taverna+Player+into+your+Rails+application">Hooking Taverna Player into your Rails application</h2>

<p>Mount the Taverna Player engine in your <code>config/routes.rb</code>. For
example:</p>

<pre class="ruby"><span class="ruby-identifier">mount</span> <span class="ruby-constant">TavernaPlayer</span><span class="ruby-operator">::</span><span class="ruby-constant">Engine</span>, :<span class="ruby-identifier">at</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;/&quot;</span>
</pre>

<p>You can also nest the Taverna Player runs resources within your workflows
resources if you wish, like this:</p>

<pre class="ruby"><span class="ruby-identifier">resources</span> :<span class="ruby-identifier">workflows</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">resources</span> :<span class="ruby-identifier">runs</span>, :<span class="ruby-identifier">controller</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;TavernaPlayer::Runs&quot;</span>, :<span class="ruby-identifier">except</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">edit</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The runs resources in Taverna Player do not provide an edit view by default
so, unless you add it yourself by overriding the controller you should add
the <code>:except</code> clause to the routes.</p>

<p>Perform Taverna Player’s migrations:</p>

<pre>rake taverna_player:install:migrations
rake db:migrate</pre>

<p>Make sure you have defined root_url to something in your
<code>config/routes.rb</code>. For example:</p>

<pre class="ruby"><span class="ruby-identifier">root</span> :<span class="ruby-identifier">to</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-node">&quot;home#index&quot;</span>
</pre>

<p>Add Taverna Player’s assets to your application’s manifests.</p>

<p>In app/assets/javascripts/application.js:</p>

<pre class="ruby"><span class="ruby-regexp">//</span>= <span class="ruby-identifier">require</span> <span class="ruby-identifier">taverna_player</span><span class="ruby-operator">/</span><span class="ruby-identifier">application</span>
</pre>

<p>In app/assets/stylesheets/application.css</p>

<pre class="ruby"><span class="ruby-operator">*=</span> <span class="ruby-identifier">require</span> <span class="ruby-identifier">taverna_player</span><span class="ruby-operator">/</span><span class="ruby-identifier">application</span>
</pre>

<p>And everything should be found by the asset pipeline automatically.</p>

<p>Make sure you have flash messages in your main layout (usually
<code>app/views/layouts/application.html.erb</code>). For example:</p>

<pre>&lt;p class=&quot;notice&quot;&gt;&lt;%= notice %&gt;&lt;/p&gt;
&lt;p class=&quot;alert&quot;&gt;&lt;%= alert %&gt;&lt;/p&gt;</pre>

<p>Taverna Player uses delayed_job to run workflows on a Taverna Server. If
your application is not already using delayed_job then you can install the
delayed_job script in your <code>script</code> directory with:</p>

<pre>rails generate taverna_player:job</pre>

<p>Taverna Player comes with some very simple, unstyled views and layouts. If
you wish to override these with your own customized views you can copy them
into your application with:</p>

<pre>rails generate taverna_player:views</pre>

<p>The views are copied to the <code>app/views/taverna_player</code> directory
so that they take precedence over the default ones. You can delete any that
you do not need to customize but there are no penalties for leaving them
there. There is more information on overriding views below.</p>

<p>If you need to override the Taverna Player controllers, to implement user
authorization for example, you can copy some customizable stubs with:</p>

<pre>rails generate taverna_player:controllers</pre>

<p>The stubs are copied to the <code>app/controllers/taverna_player</code>
directory so that they take precedence over the default ones. You can
delete any that you do not need to customize but there are no penalties for
leaving them there. There is more information on overriding controllers
below.</p>

<p>If you need to override the Taverna Player Run model, to add columns to the
table for example, you can copy a customizable stub with:</p>

<pre>rails generate taverna_player:models</pre>

<p>The stub is copied to the <code>app/models/taverna_player</code> directory
so that it takes precedence over the default one. There is more information
on overriding models below.</p>

<p>If you want to use pre- and post-run callbacks you can setup some basic
stubs with:</p>

<pre>rails generate taverna_player:callbacks</pre>

<p>They will be saved to <code>lib/taverna_player_callbacks.rb</code>. Don’t
forget to then require and register them in the Taverna Player initializer.
There is more information on callbacks below.</p>

<p>You can add to, or change, the workflow port render methods to better suit
your particular application. To copy the defaults that Taverna Player ships
with into your application for customization run:</p>

<pre>rails generate taverna_player:renderers</pre>

<p>They will be saved to <code>lib/taverna_player_renderers.rb</code>. Don’t
forget to then require and register them in the Taverna Player initializer.
There is more information on renderers below.</p>

<h2 id="label-Taverna+Player+initializers">Taverna Player initializers</h2>

<p>Two initializers are installed by the install generator:</p>
<ul><li>
<p><a
href="https://github.com/myGrid/taverna-player/blob/master/lib/generators/templates/player_initializer.rb">taverna_player.rb</a>:
This contains configuration of Taverna Player.</p>
</li><li>
<p><a
href="https://github.com/myGrid/taverna-player/blob/master/lib/generators/templates/server_initializer.rb">taverna_server.rb.example</a>:
This is used to configure Taverna Player's connection to a Taverna Server.
It is initially set up as an example file as you will need to distribute
this with your application but you must not check in the contents of the
configured version to your repository.</p>
</li></ul>

<p>Both of these files require minimal configuration for simple set ups and
are fully commented with everything that needs to be set - more details
below.</p>

<h3 id="label-Essential+%28required%29+configuration">Essential (required) configuration</h3>

<p>Firstly, Taverna Player needs to know what the model is that represents
workflows within your application and it needs to know how to get a
workflow file out of that model so it can run it. If your workflow model is
called “Workflow” and the method to get the workflow filename from that
model is called “file_name” then the following will configure this
correctly:</p>

<pre class="ruby"><span class="ruby-identifier">config</span>.<span class="ruby-identifier">workflow_model_proxy</span>(<span class="ruby-string">&quot;Workflow&quot;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">proxy</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">proxy</span>.<span class="ruby-identifier">file_method_name</span> = :<span class="ruby-identifier">file_name</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Secondly, Taverna Player needs to know where your Taverna Server is and how
to authenticate to it:</p>

<pre>config.server_address = &quot;http://localhost:8080/taverna&quot;
config.server_username = &quot;taverna&quot;
config.server_password = &quot;taverna&quot;</pre>

<p>Make sure you do not commit this information into your repository!</p>

<p>This should usually be enough to get Taverna Player up and running within
your application but there are lots of other configuration options detailed
below.</p>

<h3 id="label-Optional+configuration">Optional configuration</h3>

<h4 id="label-Taverna+Server">Taverna Server</h4>

<p>There are two settings to control how often Taverna Player communicates
with Taverna Server:</p>

<pre>config.server_poll_interval = 5
config.server_retry_interval = 10</pre>

<p>The first specifies, in seconds, how often <em>each run</em> is polled.
Polling is used to check a run’s status (has it finished yet?) and check
for interactions. If you have long running workflows then it is probably
worth setting this value higher; If you have lots of interactions then
keeping it low is good to improve the responsiveness for users. Keep in
mind that as polling is for each run then setting this value very low will
produce a lot of polling requests when you have lots of running workflows.</p>

<p>The second specifies, in seconds, how long to wait before retrying an
operation that Taverna Server has rejected due to its current load. This
can happen in two places:</p>
<ul><li>
<p>Creating the run. Each Taverna Server has a limit (usually quite high) to
how many workflow runs it can support at a time - this is the entire set of
runs resident on the server in any state (initialized, running or
finished). If it is at this limit then it will refuse requests to create
any more.</p>
</li><li>
<p>Starting the run. Each Taverna Server also has a limit to how many workflow
runs it can have actually running at once - runs that are yet to start, or
that have finished do not count towards this total. If it is at this limit
then it will refuse requests to start any more.</p>
</li></ul>

<p>Neither of these situations are fatal errors however, so Taverna Player
will back off for the specified time and then try again. It is worth
tailoring this number to the sort of workflows you will be running. For
long-running, batch-style workflows then it can be set quite high but if
you have workflows that make use of interactions (so you have users
watching the workflows running) then it should probably be set lower.</p>

<p>There are a number of options for configuring the connection to the Taverna
Server. These are actually provided by the underlying <a
href="https://rubygems.org/gems/t2-server">t2-server client library</a> and
surfaced here for extra control. They are <a
href="http://mygrid.github.io/t2-server-gem/">documented in more detail</a>
elsewhere but broadly fall into two categories: Security and timeouts.</p>

<p>The following are all concerned with connecting to a secure Taverna Server
and will be set to your Ruby/OS defaults if you leave them alone. If you
use a self-signed certificate for your server, or you require client
certificate authentication you will need to edit them appropriately.</p>

<pre>config.server_connection[:verify_peer] = true
config.server_connection[:ca_file] = &quot;/etc/certs/my-cert.crt&quot;
config.server_connection[:ca_path] = &quot;/etc/certs/&quot;
config.server_connection[:client_certificate] = &quot;client-cert.crt&quot;
config.server_connection[:client_password] = &quot;P@5$w0Rd!&quot;
config.server_connection[:ssl_version] = :TLSv1</pre>

<p>The following are timeout options and should be set with care. The
underlying operating system defaults (usually 300 seconds each) will be
used if they are not set explicitly.</p>

<pre>config.server_connection[:open_timeout] = 300
config.server_connection[:read_timeout] = 300</pre>

<h4 id="label-Users">Users</h4>

<p>If your application has users then there is some basic support for that
out-of-the-box in Taverna Player. You can tell Taverna Player what your
user model is called with (example “User” here):</p>

<pre>config.user_model_proxy = &quot;User&quot;</pre>

<p>And you can tell it how to discover who your current user is by specifying
a callback. If you are using <a
href="https://rubygems.org/gems/devise">Devise</a> (recommended) for your
authentication then you would supply the provided “current_user” method
like this:</p>

<pre>config.current_user_callback = :current_user</pre>

<p>With this set up then when a run is created Taverna Player will set the
owner of that run to be the current logged in user if there is one.</p>

<p>Note that this does not automatically mean that Taverna Player is checking
that users are authenticated! If you require this or if you have more
complex requirements then you will need to override the Run model and the
Runs controller. See below for more details.</p>

<h4 id="label-Files">Files</h4>

<p>Taverna Player needs to store various files for each run’s inputs and
outputs. The <a href="https://rubygems.org/gems/paperclip">paperclip</a>
gem is used to provide these facilities and the only configuration required
is to specify where you want it to store its files:</p>

<pre>config.file_store = &quot;:rails_root/public/system&quot;</pre>

<p>Use “:rails_root” for the root of your application, or specify a full path
for anywhere else.</p>

<h4 id="label-Run+callbacks+and+renderers">Run callbacks and renderers</h4>

<p>These are described in their own sections, below.</p>

<h2 id="label-Overriding+the+default+views">Overriding the default views</h2>

<p>If you use the generator, described above, to copy the views into your
application they will be used in preference to the default ones. This means
that any changes you make will be immediately reflected in the output of
your application. See the <a
href="http://guides.rubyonrails.org/engines.html#overriding-views">Rails
documentation</a> for more information on overriding views.</p>

<p>The supplied views provide a good example of how to maintain a current view
of the state of a run and handle any workflow interactions that may occur
during a run. It is worth understanding how they work before pulling them
apart for your own needs.</p>

<h2 id="label-Overriding+the+default+models+and+controllers">Overriding the default models and controllers</h2>

<p>You can override the following core components:</p>
<ul><li>
<p>Run (model)</p>
</li><li>
<p>RunPort (model)</p>
</li><li>
<p>RunPort::Input (model)</p>
</li><li>
<p>RunPort::Output (model)</p>
</li><li>
<p>RunsController</p>
</li><li>
<p>ServiceCredentialsController</p>
</li></ul>

<p>Use the generators, detailed above, to create stubs for you to expand.
These components have been designed for overriding with the decorator
pattern using <a
href="http://api.rubyonrails.org/classes/ActiveSupport/Concern.html">ActiveSupport::Concern</a>.
This allows for things to be overridden but still have the same name (as is
required for such things within Rails). Please also see the information
about overriding models and controllers in the <a
href="http://guides.rubyonrails.org/engines.html#overriding-models-and-controllers">Rails
documentation</a>.</p>

<p>The vitally important thing is to preserve the <code>include</code>
statement within your overriding code. For example, the RunsController stub
looks like this:</p>

<pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">TavernaPlayer</span>
  <span class="ruby-keyword">class</span> <span class="ruby-constant">RunsController</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">TavernaPlayer</span><span class="ruby-operator">::</span><span class="ruby-constant">ApplicationController</span>
    <span class="ruby-comment"># Do not remove the next line.</span>
    <span class="ruby-identifier">include</span> <span class="ruby-constant">TavernaPlayer</span><span class="ruby-operator">::</span><span class="ruby-constant">Concerns</span><span class="ruby-operator">::</span><span class="ruby-constant">Controllers</span><span class="ruby-operator">::</span><span class="ruby-constant">RunsController</span>

    <span class="ruby-comment"># Extend the RunsController here.</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>You can add code both before and after the <code>include</code> statement
but anything before it might be overridden by the original code itself if
there are name clashes.</p>

<p>If you wanted to add a before filter to authenticate your users you would
add that line before the <code>include</code> statement, for example.</p>

<h2 id="label-Run+callbacks">Run callbacks</h2>

<p>Taverna Player provides four points around a workflow run for you to
specify callbacks to be run:</p>
<ul><li>
<p>Pre-run: This is called directly before Taverna Server is contacted.</p>
</li><li>
<p>Post-run: This is called after all operations on Taverna Server have been
completed when the run finishes normally.</p>
</li><li>
<p>Run-cancelled: This is called after all operations on Taverna Server have
been completed when the run has been cancelled by the user.</p>
</li><li>
<p>Run-failed: This is called after all operations on Taverna Server have been
completed when the run has failed.</p>
</li></ul>

<p>Each of these callbacks is provided with the current run object as its
parameter and can be set in the initializer by providing the name of the
method (string or symbol) to run or a Proc object:</p>

<pre class="ruby"><span class="ruby-identifier">config</span>.<span class="ruby-identifier">pre_run_callback</span> = :<span class="ruby-identifier">player_pre_run_callback</span>
<span class="ruby-identifier">config</span>.<span class="ruby-identifier">post_run_callback</span> = <span class="ruby-string">&quot;player_post_run_callback&quot;</span>
<span class="ruby-identifier">config</span>.<span class="ruby-identifier">run_cancelled_callback</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">run</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Cancelled: #{run.name}&quot;</span> }
<span class="ruby-identifier">config</span>.<span class="ruby-identifier">run_failed_callback</span> = :<span class="ruby-identifier">player_run_failed_callback</span>
</pre>

<p><strong>Important!</strong> If your callback fails then the run itself will
"fail". This may or may not matter for the run-failed callback but if your
pre-run callback fails then the run will never get to Taverna Server! How
can it? Your pre-run callback may have been setting up vital resources for
your run; Taverna Player can not second-guess this so "fails" the run.</p>

<p>For this reason it is not recommended to put a lot of complex functionality
into the callbacks. An ideal use would be to gather statistics from the run
(average time, how many times a user runs it, etc) once it has finished.</p>

<p>An example callback that just prints out the run’s name and workflow id
would be:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">player_run_callback</span>(<span class="ruby-identifier">run</span>)
  <span class="ruby-identifier">w</span> = <span class="ruby-constant">Workflow</span>.<span class="ruby-identifier">find</span>(<span class="ruby-identifier">run</span>.<span class="ruby-identifier">workflow_id</span>)
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Callback called for run '#{run.name}' of workflow '#{w.id}'&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>A set of example callbacks can be installed with the generator detailed
above. Don’t forget to make sure any callback code is <code>require</code>d
somewhere and the callbacks themselves registered in the initializer.</p>

<h2 id="label-Rendering+workflow+ports">Rendering workflow ports</h2>

<p>Workflows can accept inputs and produce results in many different formats
and Taverna Player tries to accomodate this as best it can. It provides
basic facilities for rendering as many types as it can and these are
extensible wherever possible.</p>

<p>Calling the port renderer is as simple as just passing it the port to be
rendered in your view.</p>

<pre>&lt;% run.outputs.each do |output| %&gt;
  &lt;%= TavernaPlayer.port_renderer.render(output) %&gt;
&lt;% end %&gt;</pre>

<h3 id="label-Type+renderers">Type renderers</h3>

<p>Taverna Player has a system of specific type renderers to handle different
types of value. A number of defaults are supplied but these can be replaced
and added to if required.</p>

<p>To install a set of example renderers you can use the generator detailed
above.</p>

<p>To register a renderer for use add it into the renderers block in the
initializer:</p>

<pre class="ruby"><span class="ruby-identifier">config</span>.<span class="ruby-identifier">port_renderers</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">renderers</span><span class="ruby-operator">|</span>
  <span class="ruby-operator">...</span>
<span class="ruby-keyword">end</span>
</pre>

<p>So to just register a single default renderer method (called
“my_default_renderer”) you would do this:</p>

<pre class="ruby"><span class="ruby-identifier">config</span>.<span class="ruby-identifier">port_renderers</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">renderers</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">renderers</span>.<span class="ruby-identifier">default</span>(:<span class="ruby-identifier">my_default_renderer</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>And it would be used to render every type of value. A more sensible example
would be to have a renderer for PNG-type images and a renderer for text
values as well:</p>

<pre class="ruby"><span class="ruby-identifier">config</span>.<span class="ruby-identifier">port_renderers</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">renderers</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">renderers</span>.<span class="ruby-identifier">default</span>(:<span class="ruby-identifier">my_default_renderer</span>)
  <span class="ruby-identifier">renderers</span>.<span class="ruby-identifier">add</span>(<span class="ruby-string">&quot;text/plain&quot;</span>, :<span class="ruby-identifier">text_renderer</span>, <span class="ruby-keyword">true</span>)
  <span class="ruby-identifier">renderers</span>.<span class="ruby-identifier">add</span>(<span class="ruby-string">&quot;image/png&quot;</span>, :<span class="ruby-identifier">show_image</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>This does three things:</p>
<ul><li>
<p>Registers a renderer for PNG images. This could be as simple as wrapping it
in an <code>&lt;img ../&gt;</code> tag.</p>
</li><li>
<p>Registers a renderer for values of type “text/plain” and <em>sets this as
the default renderer for all other types beginning with “text”</em>. That
is what the final parameter set to <code>true</code> does.</p>
</li><li>
<p>Registers a default renderer for all other types. This should probably give
an explanation as to why the value cannot be shown in the browser with a
link to download the value to the user’s computer.</p>
</li></ul>

<p>Note the use of MIME types for specifying all types.</p>

<p>Obviously values such as images and text are so common that Taverna Player
provides these renderers for you and has them set up and registered by
default. You would only need to override them if you wanted extra
information to be displayed as well, such as sizes next to images, etc.</p>

<p>Note that it is not a good idea to register a single image renderer for all
“image” types as many cannot be shown in most browsers, e.g. TIFF images.
The default set of registered renderers is shown in the default initializer
but, as an example, here is how it handles the images that most browsers
can show:</p>

<pre>renderers.add(&quot;image/jpeg&quot;, :show_image)
renderers.add(&quot;image/png&quot;, :show_image)
renderers.add(&quot;image/gif&quot;, :show_image)
renderers.add(&quot;image/bmp&quot;, :show_image)</pre>

<p>Note that the same renderer callback is used for each one.</p>

<h3 id="label-Rendering+lists">Rendering lists</h3>

<p>Taverna workflow inputs and output can be lists and rendering them requires
a</p>

<h3 id="label-Writing+your+own+renderers">Writing your own renderers</h3>

<p>To be a renderer callback a method must accept two parameters (in this
order):</p>
<ol><li>
<p>The port to be rendered.</p>
</li><li>
<p>A list of indices into the port. For a singleton port this will be an empty
list. For a port of depth 2 this would be a list with two items, e.g.
<code>[0, 0]</code></p>
</li></ol>

<p>All renderer callbacks are called by Taverna Player in a context that
includes the <a
href="http://api.rubyonrails.org/classes/ActionView/Helpers.html">ActionView::Helpers</a>
so your callbacks have access to them too, including helpers from
third-party gems that register their helpers correctly.</p>

<h3 id="label-Example+type+renderers">Example type renderers</h3>

<p>These are some of the supplied renderers that are registered by default in
Taverna Player.</p>

<h4 id="label-Plain+text">Plain text</h4>

<p>Taverna Player provides a plain text renderer that formats text with a
monospaced font, converts URI-like things to clickable links and respects
carriage returns and newlines. It looks something like this:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">format_text</span>(<span class="ruby-identifier">port</span>, <span class="ruby-identifier">index</span> = [])
  <span class="ruby-comment"># Use CodeRay to format text so that newlines are respected.</span>
  <span class="ruby-identifier">content</span> = <span class="ruby-constant">CodeRay</span>.<span class="ruby-identifier">scan</span>(<span class="ruby-identifier">port</span>.<span class="ruby-identifier">value</span>(<span class="ruby-identifier">index</span>), :<span class="ruby-identifier">text</span>).<span class="ruby-identifier">div</span>(:<span class="ruby-identifier">css</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-keyword">class</span>)

  <span class="ruby-comment"># Use auto_link to turn URI-like text into links.</span>
  <span class="ruby-identifier">auto_link</span>(<span class="ruby-identifier">content</span>, :<span class="ruby-identifier">html</span> =<span class="ruby-operator">&gt;</span> { :<span class="ruby-identifier">target</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'_blank'</span> }, :<span class="ruby-identifier">sanitize</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>The <a href="https://rubygems.org/gems/coderay">coderay</a> gem is used to
format the text, preserving newlines and the <a
href="https://rubygems.org/gems/rails_autolink">rails_autolink</a> gem is
used to convert URI-like text into clickable links.</p>

<p>This renderer is registered as the default for all “text” media types.</p>

<h4 id="label-XML">XML</h4>

<p>This renderer catches “text/XML” outputs:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">format_xml</span>(<span class="ruby-identifier">port</span>, <span class="ruby-identifier">index</span> = [])
  <span class="ruby-comment"># Make sure XML is indented consistently.</span>
  <span class="ruby-identifier">out</span> = <span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-constant">REXML</span><span class="ruby-operator">::</span><span class="ruby-constant">Document</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">port</span>.<span class="ruby-identifier">value</span>(<span class="ruby-identifier">index</span>)).<span class="ruby-identifier">write</span>(<span class="ruby-identifier">out</span>, <span class="ruby-value">1</span>)
  <span class="ruby-constant">CodeRay</span>.<span class="ruby-identifier">scan</span>(<span class="ruby-identifier">out</span>, :<span class="ruby-identifier">xml</span>).<span class="ruby-identifier">div</span>(:<span class="ruby-identifier">css</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-keyword">class</span>, :<span class="ruby-identifier">line_numbers</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">table</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>It uses <a
href="http://ruby-doc.org/stdlib-1.9.3/libdoc/rexml/rdoc/index.html">REXML</a>
to format the XML and <a
href="https://rubygems.org/gems/coderay">coderay</a> to syntax-highlight
it.</p>

<p>Note that for XML to be detected as XML it must, as per the standard,
include the XML declaration, e.g.:</p>

<pre>&lt;?xml version=&quot;1.0&quot; ?&gt;</pre>

<h4 id="label-Images">Images</h4>

<p>As described above, images are just dropped into an <code>&lt;img
../&gt;</code> tag:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">show_image</span>(<span class="ruby-identifier">port</span>, <span class="ruby-identifier">index</span> = [])
  <span class="ruby-comment"># Can't use image_tag() here because the image doesn't really exist (it's</span>
  <span class="ruby-comment"># in a zip file, really) and this confuses the Rails asset pipeline.</span>
  <span class="ruby-identifier">tag</span>(<span class="ruby-string">&quot;img&quot;</span>, :<span class="ruby-identifier">src</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">port</span>.<span class="ruby-identifier">path</span>(<span class="ruby-identifier">index</span>))
<span class="ruby-keyword">end</span>
</pre>

<p>Note the comment about the Rails asset pipeline in there if you are writing
your own image renderer and are using the asset pipeline.</p>

<h4 id="label-Lists">Lists</h4>

<p>Unless you can be absolutely sure that the workflows that will be run
within your installation of Taverna Player will only have lists of a
certain depth the lists renderer will need to be able to cope with anything
that is thrown at it. The supplied renderer uses recursion to cope with
what could, at least in theory, be infinitely deep lists:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">list_port</span>(<span class="ruby-identifier">port</span>, <span class="ruby-identifier">index</span> = [], <span class="ruby-identifier">types</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">types</span> = <span class="ruby-identifier">port</span>.<span class="ruby-identifier">metadata</span>[:<span class="ruby-identifier">type</span>] <span class="ruby-keyword">if</span> <span class="ruby-identifier">types</span>.<span class="ruby-identifier">nil?</span>

  <span class="ruby-identifier">content</span> = <span class="ruby-string">&quot;&lt;ol&gt;&quot;</span>
  <span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>
  <span class="ruby-identifier">types</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">type</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">type</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
      <span class="ruby-identifier">content</span> <span class="ruby-operator">+=</span> <span class="ruby-string">&quot;&lt;li&gt;&lt;br /&gt;&quot;</span> <span class="ruby-operator">+</span>
      <span class="ruby-identifier">list_port</span>(<span class="ruby-identifier">port</span>, <span class="ruby-identifier">index</span> <span class="ruby-operator">+</span> [<span class="ruby-identifier">i</span>], <span class="ruby-identifier">type</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;&lt;/li&gt;&quot;</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">content</span> <span class="ruby-operator">+=</span> <span class="ruby-node">&quot;&lt;li&gt;(#{type})&lt;p&gt;&quot;</span> <span class="ruby-operator">+</span>
        <span class="ruby-constant">TavernaPlayer</span>.<span class="ruby-identifier">port_renderer</span>.<span class="ruby-identifier">render</span>(<span class="ruby-identifier">port</span>, <span class="ruby-identifier">index</span> <span class="ruby-operator">+</span> [<span class="ruby-identifier">i</span>]) <span class="ruby-operator">+</span>
        <span class="ruby-string">&quot;&lt;/p&gt;&lt;/li&gt;&quot;</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">i</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">content</span> <span class="ruby-operator">+=</span> <span class="ruby-string">&quot;&lt;/ol&gt;&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This method has an extra parameter that is used to drive the recursion. The
<code>types</code> parameter contains the list structure of the whole port
so can be used to loop over, or recurse into, each level as required.</p>

<p>Lists are simply rendered as a numbered list along with their type
information. Other registered renderers are called as necessary to render
individual values.</p>

<h4 id="label-Other+types+catch-all">Other types catch-all</h4>

<p>The default renderer for other, or unknown types, is:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">cannot_inline</span>(<span class="ruby-identifier">port</span>, <span class="ruby-identifier">index</span> = [])
  <span class="ruby-string">&quot;Sorry but we cannot show this type of content in the browser. Please &quot;</span> <span class="ruby-operator">+</span>
    <span class="ruby-identifier">link_to</span>(<span class="ruby-string">&quot;download it&quot;</span>, <span class="ruby-identifier">port</span>.<span class="ruby-identifier">path</span>(<span class="ruby-identifier">index</span>)) <span class="ruby-operator">+</span> <span class="ruby-string">&quot; to view it on your &quot;</span> <span class="ruby-operator">+</span>
    <span class="ruby-string">&quot;local machine.&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

<h2 id="label-Service+Credentials">Service Credentials</h2>

<p><strong>Please see the notes in the limitations section below!</strong></p>

<p>At the moment the Service Credentials facilities are basic and provided
purely to allow access to services which are ostensibly public but still
require a login of some kind.</p>

<p>In practice very few services that will be used via public tools such as
Taverna Player are in use so this should not affect most users at this
time. It is the intention to fill this gap in functionality as soon as
possible, however.</p>

<p>If you do have services in your workflows that require such a login then
you can add them through the Service Credentials model. The types of
credential that Taverna Server can accept are detailed in the <a
href="http://mygrid.github.io/t2-server-gem/">Client Library
Documentation</a> but Taverna Player supports a subset:</p>

<h3 id="label-REST">REST</h3>

<p>REST services are commonly secured via HTTP Basic or HTTP Digest
authentication and Taverna treats these two schemes in the same way. Simply
register the username and password with the host name of the server on
which the service is running:</p>

<pre>https://example.com:8443/</pre>

<p>The above example shows a https server running on port 8443. If the service
is on port 80 for http or port 443 for https then you don’t need to specify
the port.</p>

<p>If there are services on the same host that require different credentials
then you will need to specify the realm for which each set of credentials
applies. This is done by adding the name of the realm to the end of the
host name with a # separating them:</p>

<pre>https://example.com:8443/#realm</pre>

<h3 id="label-SOAP">SOAP</h3>

<p>SOAP services are commonly secured via WS-Security. Simply register the
WSDL address of the service with your username and password:</p>

<pre>https://example.com:8443/services/MyService?wsdl</pre>

<h3 id="label-R+server">R server</h3>

<p>You can authenticate to R Servers in almost exactly the same way as for
REST services - only the protocol scheme is different. So instead of http
or https it is rserve:</p>

<pre>rserve://example.com:6311</pre>

<h2 id="label-Limitations+and+to-do+list">Limitations and to-do list</h2>

<p>The most serious limitation is with the Service Credentials. Because
Taverna Server needs to be given the credentials in plaintext (which is why
you should always use HTTPS) we have to store them as such. For the time
being it is recommended to only use them for services that are ostensibly
public, but with a login requirement. An example of this might be a R
server on the local machine, which is only available locally, but
nevertheless requires a login.</p>

<p>Service Credentials are also intended, at the moment, to be a global
resource. They are not per-user. Every workflow run will be given these
credentials.</p>

<p>Service Credentials only provide username/password type credentials at the
moment.</p>

<h3 id="label-To+do">To do</h3>

<p>In no particular order:</p>
<ul><li>
<p>Taverna Player as a service. Allow usage of Taverna Player via a fully
RESTful interface with JSON and XML support (in progress).</p>
</li><li>
<p>User specific (and therefore private) credentials wallet for secure
services.</p>
</li><li>
<p>Comprehensive Taverna Server administration panel. This would allow admin
users to view and manage runs directly on the Taverna Server along with
other such admin tasks.</p>
</li><li>
<p>I18n support.</p>
</li><li>
<p>oEmbed support (see <a href="http://oembed.com/">oembed.com/</a> for more
details).</p>
</li></ul>

<h2 id="label-Support">Support</h2>

<p>Please email <a
href="mailto:support@mygrid.org.uk">support@mygrid.org.uk</a> for any
questions relating to Taverna Player.</p>

<p>Bug reports or feature requests may be submitted to the <a
href="https://github.com/myGrid/taverna-player/issues">public issue
tracker</a> at GitHub.</p>

</div>



<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 3.12.2.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

